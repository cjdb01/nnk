/*
 * Christopher Di Bella <chrisdb@cse.unsw.edu.au>
 *
 * 1 November, 2013
 *
 * som.h
 * The self-organising map implementation.
 *
 * Coding conventions documented in som.h.
 *
 * Note that this is a C++11 file, subject to GCC 4.7.2, as on the CSE machines
 *
 * Copyright (c) Christopher 2013, under the MIT License.
 * All rights reserved.
 */
 
namespace pipe
{
    /*
     * To save space, unused template parameters will be referred to by only the letters
     * that start each word. Template parameters that are actually used will have a meaningful
     * name instead of a shorthand equivalent. If you don't need to know about it, its name is
     * meaningless anyway!
     */
    template <typename T, size_t IS, size_t OSX, size_t OSY>
    kohonen<T, IS, OSX, OSY>::kohonen(const T& ilr, const T& lr_decay, const T& inbd_width, const T& nbd_width_decay, const T& min_weight, const T& max_weight)
     : m_learningRate(ilr), m_lrDecay(lr_decay), m_nbdWidth(inbd_width), m_nbdWidthDecay(nbd_width_decay), m_random(std::chrono::system_clock::now().time_since_epoch().count()), m_distribute(min_weight, max_weight) {}

    template <typename T, size_t IS, size_t OSX, size_t OSY>
    kohonen<T, IS, OSX, OSY>::kohonen(std::istream& in, const T& ilr, const T& lr_decay, const T& inbd_width, const T& nbd_width_decay, const T& min_weight, const T& max_weight) : kohonen(ilr, lr_decay, inbd_width, nbd_width_decay, min_weight, max_weight)
    {
        input_type a;
        output_type b;

        while (in.eof() == false)
        {
            std::for_each(a.begin(), a.end(), (input_type::iterator& it) [&] { in >> *it; in.get(); });

            for (auto i = b.begin() : b.end())
            {
                for (auto j = i.begin() : i.end())
                {
                    *j = tiny_rand();
                }
            }

            m_input.push_back(a);
            m_output.push_back(b);
        }
    }
    
    template <typename T, size_t IS, size_t OSX, size_t OSY>
    void kohonen<T, IS, OSX, OSY>::decay()
    {
        m_learningRate *= 1 - LRDecay;
        m_nbdWidth     *= 1 - NbdWidthDecay;
    }

    template <typename T, size_t IS, size_t OSX, size_t OSY>
    T kohonen<T, IS, OSX, OSY>::tiny_rand() const
    {
        return m_distribute(m_random);
    }
    
    template <typename T, size_t InputSize, size_t OSX, size_t OSY>
    template <typename Container>
    T kohonen<T, IS, OSX, OSY>::euclidean_distance_squared(const Container& x, const Container& y) const
    {
        // Euclidean distance = sqrt(sum((x_i - y_i)^2))
        T sum = 0;
        for (auto i = 0; i < InputSize; ++i)
        {
            sum += std::pow(x[i] - y[i], 2);
        }
        
        return sum;
    }
    
    template <typename T, size_t IS, size_t OSX, size_t OSY>
    T kohonen<T, IS, OSX, OSY>::h(const input_type& j) const
    {
        return std::exp(-euclidean_distance_squared(j, &m_winningNeuron) / (2 * std::pow(m_nbdWidth, 2)));
    }
    
    template <typename T, size_t IS, size_t OSX, size_t OSY>
    void kohonen<T, IS, OSX, OSY>::adjust_weight()
    {
        for (auto i = 0; i < OutputSizeX; ++i)
        {
            for (auto j = 0; j < OutputSizeY
        }
    }
}